一：JUNIT
JUNIT需要另外导包

JUNIT 3.0 4.0

文件夹test -> 包与待测试的包名相同 -> 类TestDemo -> 方法名 test+待测试方法名+没有参数(public void 方法名()) ->	在方法的上面 @Test -> 选中方法名称，run as JUNIT	

@Test
@Ignore
@Before
@After
******************************************************************************************************
******************************************************************************************************
******************************************************************************************************
	*****************泛型	可变参数	枚举	自动拆装箱	都是JDK5.0的新特性*****************
******************************************************************************************************
******************************************************************************************************
******************************************************************************************************
二：泛型

	public static <T> void swap(T[] arr,int pos1,int pos2){

	}
	》泛型只会在编译阶段进行限制，使用反射可以绕过泛型

	
三：可变参数

public int add(int... nums){
	int res = 0;
	for(int i=0;i<nums.length;i++)
		res += nums[i];
	return res;
}


四：枚举

enum{
	MON,
}
0.	可以将enum看作是一个完整的类，可以将枚举值看作是一个类的对象
他可以有属性、默认构造方法、构造方法等
1.	ENUM的构造方法
	》只能是private类型的，即不能新建Enum对象
	》构造函数可以重载，
3.	ENUM可以拥有抽象方法
	》只能是public 或 protected类型
	》每个枚举对象都必须实现，可以体现出各枚举对象之间的不同
4.	可以重写Enum<T>的toString()方法
5.	继承自Enum的方法有：
  	》ordinal() 枚举值在枚举类种中声明的顺序
	》compareTo() 返回两个枚举值的顺序之差
  	》equals() 两个枚举值是否相同
	》name() 返回枚举值的名称
	》toString() 返回枚举值的名称
	》valueof() 通过枚举值的名称得到枚举值
	》values() 得到枚举值的数组

五：自动拆装箱
******************************************************************************************************
******************************************************************************************************
******************************************************************************************************
	*****************泛型	可变参数	枚举	自动拆装箱	都是JDK5.0的新特性*****************
******************************************************************************************************
******************************************************************************************************
******************************************************************************************************

六：反射 万物皆对象，
实例化的两种方式：
	Student s = new Student();
	Srudent s = Class.forname(com.zhong.Student);
	
反射和基本数据类型是java中两种 并不面向对象的东西

七：线程
》内部类只能访问final对象
》ThreadLocal通常用在一个类的成员上 ThreadLocal<Person> tl = new ThreadLocal<Preson>();
	*多个线程访问他时，每个线程都有自己的副本，互不干扰
	*ThreadLocal#get()		Person p = tl.get()
	*ThreadLocal#set() 		tl.set(p);
	*ThreadLocal#remove()	tl.remove()
class User{
	ThreadLocal<String> UsrenameTL = new ThreadLocal<String>();
	Stirng password;
}

is a	继承 人is a动物 是你
has a					有你
use a					全靠你

继承：被增强对象固定，增强类固定
装饰者模式：被增强对象固定，增强类不固定
动态代理：被增强对象不固定，增强类不固定


